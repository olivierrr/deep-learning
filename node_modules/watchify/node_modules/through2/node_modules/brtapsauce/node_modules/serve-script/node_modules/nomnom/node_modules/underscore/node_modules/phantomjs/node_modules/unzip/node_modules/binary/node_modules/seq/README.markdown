Seq
===

Seq is an asynchronous flow control library with a chainable interface for
sequential and parallel actions. Even the error handling is chainable.

Each action in the chain operates on a stack of values.
There is also a variables hash for storing values by name.

Examples
========

stat_all.js
-----------

    var fs = require('fs');
    var Hash = require('hashish');
    var Seq = require('seq');
    
    Seq()
        .seq(function () {
            fs.readdir(__dirname, this);
        })
        .flatten()
        .parEach(function (file) {
            fs.stat(__dirname + '/' + file, this.into(file));
        })
        .seq(function () {
            var sizes = Hash.map(this.vars, function (s) { return s.size })
            console.dir(sizes);
        })
    ;

Output:

    { 'stat_all.js': 404, 'parseq.js': 464 }

parseq.js
---------

    var fs = require('fs');
    var exec = require('child_process').exec;
    
    var Seq = require('seq');
    Seq()
        .seq(function () {
            exec('whoami', this)
        })
        .par(function (who) {
            exec('groups ' + who, this);
        })
        .par(function (who) {
            fs.readFile(__filename, 'ascii', this);
        })
        .seq(function (groups, src) {
            console.log('Groups: ' + groups.trim());
            console.log('This file has ' + src.length + ' bytes');
        })
    ;

Output:

    Groups: substack : substack dialout cdrom floppy audio src video plugdev games netdev fuse www
    This file has 464 bytes

Methods
=======

Each method executes callbacks with a context (its `this`) described in the next
section. Every method returns `this`.

Whenever `this()` is called with a non-falsy first argument, the error value
propagates down to the first `catch` it sees, skipping over all actions in
between. There is an implicit `catch` at the end of all chains that prints the
error stack if available and otherwise just prints the error.

Seq()
-----
Seq(x, y...)
------------

The constructor function creates a new `Seq` chain with the methods described
below. The optional arguments given become the new context stack.

Seq.ap([x, y...])
-----------------

Exactly like `Seq(x, y...)` or `Seq().extend([x,y...])`.
This is just another handy way for populating the stack.
The `ap` is short for `apply`.

seq(cb)
-------
seq(key, cb, *args)
-------------------

This eponymous function executes actions sequentially.
Once all running parallel actions are finished executing,
the supplied callback is `apply()`'d with the context stack.

To execute the next action in the chain, call `this()`. The first
argument must be the error value. The rest of the values will become the stack
for the next action in the chain and are also available at `this.args`.

If `key` is specified, the second argument sent to `this` goes to
`this.vars[key]` in addition to the stack and `this.args`.
`this.vars` persists across all requests unless it is overwritten.

All arguments after `cb` will be bound to `cb`, which is useful because
`.bind()` makes you se