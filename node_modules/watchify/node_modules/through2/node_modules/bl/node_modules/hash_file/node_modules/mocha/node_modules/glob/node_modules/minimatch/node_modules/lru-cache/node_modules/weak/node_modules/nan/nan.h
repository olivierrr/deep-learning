/**********************************************************************************
 * NAN - Native Abstractions for Node.js
 *
 * Copyright (c) 2014 NAN contributors:
 *   - Rod Vagg <https://github.com/rvagg>
 *   - Benjamin Byholm <https://github.com/kkoopa>
 *   - Trevor Norris <https://github.com/trevnorris>
 *   - Nathan Rajlich <https://github.com/TooTallNate>
 *   - Brett Lawson <https://github.com/brett19>
 *   - Ben Noordhuis <https://github.com/bnoordhuis>
 *
 * MIT +no-false-attribs License <https://github.com/rvagg/nan/blob/master/LICENSE>
 *
 * Version 1.2.0 (current Node unstable: 0.11.13, Node stable: 0.10.28)
 *
 * ChangeLog:
 *  * 1.2.0 Jun 5 2015
 *    - Add NanSetPrototypeTemplate
 *    - Changed NAN_WEAK_CALLBACK internals, switched _NanWeakCallbackData to class,
 *      introduced _NanWeakCallbackDispatcher
 *    - Removed -Wno-unused-local-typedefs from test builds
 *    - Made test builds Windows compatible ('Sleep()')
 * `
 *  * 1.1.2 May 28 2014
 *    - Release to fix more stuff-ups in 1.1.1
 *
 *  * 1.1.1 May 28 2014
 *    - Release to fix version mismatch in nan.h and lack of changelog entry for 1.1.0
 *
 *  * 1.1.0 May 25 2014
 *    - Remove nan_isolate, use v8::Isolate::GetCurrent() internally instead
 *    - Additional explicit overloads for NanNew(): (char*,int), (uint8_t*[,int]),
 *      (uint16_t*[,int), double, int, unsigned int, bool, v8::String::ExternalStringResource*,
 *      v8::String::ExternalAsciiStringResource*
 *    - Deprecate NanSymbol()
 *    - Added SetErrorMessage() and ErrorMessage() to NanAsyncWorker
 *
 *  * 1.0.0 May 4 2014
 *    - Heavy API changes for V8 3.25 / Node 0.11.13
 *    - Use cpplint.py
 *    - Removed NanInitPersistent
 *    - Removed NanPersistentToLocal
 *    - Removed NanFromV8String
 *    - Removed NanMakeWeak
 *    - Removed NanNewLocal
 *    - Removed NAN_WEAK_CALLBACK_OBJECT
 *    - Removed NAN_WEAK_CALLBACK_DATA
 *    - Introduce NanNew, replaces NanNewLocal, NanPersistentToLocal, adds many overloaded typed versions
 *    - Introduce NanUndefined, NanNull, NanTrue and NanFalse
 *    - Introduce NanEscapableScope and NanEscapeScope
 *    - Introduce NanMakeWeakPersistent (requires a special callback to work on both old and new node)
 *    - Introduce NanMakeCallback for node::MakeCallback
 *    - Introduce NanSetTemplate
 *    - Introduce NanGetCurrentContext
 *    - Introduce NanCompileScript and NanRunScript
 *    - Introduce NanAdjustExternalMemory
 *    - Introduce NanAddGCEpilogueCallback, NanAddGCPrologueCallback, NanRemoveGCEpilogueCallback, NanRemoveGCPrologueCallback
 *    - Introduce NanGetHeapStatistics
 *    - Rename NanAsyncWorker#SavePersistent() to SaveToPersistent()
 *
 *  * 0.8.0 Jan 9 2014
 *    - NanDispose -> NanDisposePersistent, deprecate NanDispose
 *    - Extract _NAN_*_RETURN_TYPE, pull up NAN_*()
 *
 *  * 0.7.1 Jan 9 2014
 *    - Fixes to work against debug builds of Node
 *    - Safer NanPersistentToLocal (avoid reinterpret_cast)
 *    - Speed up common NanRawString case by only extracting flattened string when necessary
 *
 *  * 0.7.0 Dec 17 2013
 *    - New no-arg form of NanCallback() constructor.
 *    - NanCallback#Call takes Handle rather than Local
 *    - Removed deprecated NanCallback#Run method, use NanCallback#Call instead
 *    - Split off _NAN_*_ARGS_TYPE from _NAN_*_ARGS
 *    - Restore (unofficial) Node 0.6 compatibility at NanCallback#Call()
 *    - Introduce NanRawString() for char* (or appropriate void*) from v8::String
 *      (replacement for NanFromV8String)
 *    - Introduce NanCString() for null-terminated char* from v8::String
 *
 *  * 0.6.0 Nov 21 2013
 *    - Introduce NanNewLocal<T>(v8::Handle<T> value) for use in place of
 *      v8::Local<T>::New(...) since v8 started requiring isolate in Node 0.11.9
 *
 *  * 0.5.2 Nov 16 2013
 *    - Convert SavePersistent and GetFromPersistent in NanAsyncWorker from protected and public
 *
 *  * 0.5.1 Nov 12 2013
 *    - Use node::MakeCallback() instead of direct v8::Function::Call()
 *
 *  * 0.5.0 Nov 11 2013
 *    - Added @TooTallNate as collaborator
 *    - New, much simpler, "include_dirs" for binding.gyp
 *    - Added full range of NAN_INDEX_* macros to match NAN_PROPERTY_* macros
 *
 *  * 0.4.4 Nov 2 2013
 *    - Isolate argument from v8::Persistent::MakeWeak removed for 0.11.8+
 *
 *  * 0.4.3 Nov 2 2013
 *    - Include node_object_wrap.h, removed from node.h for Node 0.11.8.
 *
 *  * 0.4.2 Nov 2 2013
 *    - Handle deprecation of v8::Persistent::Dispose(v8::Isolate* isolate)) for
 *      Node 0.11.8 release.
 *
 *  * 0.4.1 Sep 16 2013
 *    - Added explicit `#include <uv.h>` as it was removed from node.h for v0.11.8
 *
 *  * 0.4.0 Sep 2 2013
 *    - Added NAN_INLINE and NAN_DEPRECATED and made use of them
 *    - Added NanError, NanTypeError and NanRangeError
 *    - Cleaned up code
 *
 *  * 0.3.2 Aug 30 2013
 *    - Fix missing scope declaration in GetFromPersistent() and SaveToPersistent
 *      in NanAsyncWorker
 *
 *  * 0.3.1 Aug 20 2013
 *    - fix "not all control paths return a value" compile warning on some platforms
 *
 *  * 0.3.0 Aug 19 2013
 *    - Made NAN work with NPM
 *    - Lots of fixes to NanFromV8String, pulling in features from new Node core
 *    - Changed node::encoding to Nan::Encoding in NanFromV8String to unify the API
 *    - Added optional error number argument for NanThrowError()
 *    - Added NanInitPersistent()
 *    - Added NanReturnNull() and NanReturnEmptyString()
 *    - Added NanLocker and NanUnlocker
 *    - Added missing scopes
 *    - Made sure to clear disposed Persistent handles
 *    - Changed NanAsyncWorker to allocate error messages on the heap
 *    - Changed NanThrowError(Local<Value>) to NanThrowError(Handle<Value>)
 *    - Fixed leak in NanAsyncWorker when errmsg is used
 *
 *  * 0.2.2 Aug 5 2013
 *    - Fixed usage of undefined variable with node::BASE64 in NanFromV8String()
 *
 *  * 0.2.1 Aug 5 2013
 *    - Fixed 0.8 breakage, node::BUFFER encoding type not available in 0.8 for
 *      NanFromV8String()
 *
 *  * 0.2.0 Aug 5 2013
 *    - Added NAN_PROPERTY_GETTER, NAN_PROPERTY_SETTER, NAN_PROPERTY_ENUMERATOR,
 *      NAN_PROPERTY_DELETER, NAN_PROPERTY_QUERY
 *    - Extracted _NAN_METHOD_ARGS, _NAN_GETTER_ARGS, _NAN_SETTER_ARGS,
 *      _NAN_PROPERTY_GETTER_ARGS, _NAN_PROPERTY_SETTER_ARGS,
 *      _NAN_PROPERTY_ENUMERATOR_ARGS, _NAN_PROPERTY_DELETER_ARGS,
 *      _NAN_PROPERTY_QUERY_ARGS
 *    - Added NanGetInternalFieldPointer, NanSetInternalFieldPointer
 *    - Added NAN_WEAK_CALLBACK, NAN_WEAK_CALLBACK_OBJECT,
 *      NAN_WEAK_CALLBACK_DATA, NanMakeWeak
 *    - Renamed THROW_ERROR to _NAN_THROW_ERROR
 *    - Added NanNewBufferHandle(char*, size_t, node::smalloc::FreeCallback, void*)
 *    - Added NanBufferUse(char*, uint32_t)
 *    - Added NanNewContextHandle(v8::ExtensionConfiguration*,
 *        v8::Handle<v8::ObjectTemplate>, v8::Handle<v8::Value>)
 *    - Fixed broken NanCallback#GetFunction()
 *    - Added optional encoding and size arguments to NanFromV8String()
 *    - Added NanGetPointerSafe() and NanSetPointerSafe()
 *    - Added initial test suite (to be expanded)
 *    - Allow NanUInt32OptionValue to convert any Number object
 *
 *  * 0.1.0 Jul 21 2013
 *    - Added `NAN_GETTER`, `NAN_SETTER`
 *    - Added `NanThrowError` with single Local<Value> argument
 *    - Added `NanNewBufferHandle` with single uint32_t argument
 *    - Added `NanHasInstance(Persistent<FunctionTemplate>&, Handle<Value>)`
 *    - Added `Local<Function> NanCallback#GetFunction()`
 *    - Added `NanCallback#Call(int, Local<Value>[])`
 *    - Deprecated `NanCallback#Run(int, Local<Value>[])` in favour of Call
 *
 * See https://github.com/rvagg/nan for the latest update to this file
 **********************************************************************************/

#ifndef NAN_H_
#define NAN_H_

#include <uv.h>
#include <node.h>
#include <node_buffer.h>
#include <node_version.h>
#include <node_object_wrap.h>
#include <string.h>

#if defined(__GNUC__) && !defined(DEBUG)
# define NAN_INLINE inline __attribute__((always_inline))
#elif defined(_MSC_VER) && !defined(DEBUG)
# define NAN_INLINE __forceinline
#else
# define NAN_INLINE inline
#endif

#if defined(__GNUC__) && !V8_DISABLE_DEPRECATIONS
# define NAN_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER) && !V8_DISABLE_DEPRECATIONS
# define NAN_DEPRECATED __declspec(deprecated)
#else
# define NAN_DEPRECATED
#endif

// some generic helpers

template<typename T> NAN_INLINE bool NanSetPointerSafe(
    T *var
  , T val
) {
  if (var) {
    *var = val;
    return true;
  } else {
    return false;
  }
}

template<typename T> NAN_INLINE T NanGetPointerSafe(
    T *var
  , T fallback = reinterpret_cast<T>(0)
) {
  if (var) {
    return *var;
  } else {
    return fallback;
  }
}

NAN_INLINE bool NanBooleanOptionValue(
    v8::Local<v8::Object> optionsObj
  , v8::Handle<v8::String> opt, bool def
) {
  if (def) {
    return optionsObj.IsEmpty()
      || !optionsObj->Has(opt)
      || optionsObj->Get(opt)->BooleanValue();
  } else {
    return !optionsObj.IsEmpty()
      && optionsObj->Has(opt)
      && optionsObj->Get(opt)->BooleanValue();
  }
}

NAN_INLINE bool NanBooleanOptionValue(
    v8::Local<v8::Object> optionsObj
  , v8::Handle<v8::String> opt
) {
  return NanBooleanOptionValue(optionsObj, opt, false);
}

NAN_INLINE uint32_t NanUInt32OptionValue(
    v8::Local<v8::Object> optionsObj
  , v8::Handle<v8::String> opt
  , uint32_t def
) {
  return !optionsObj.IsEmpty()
    && optionsObj->Has(opt)
    && optionsObj->Get(opt)->IsNumber()
      ? optionsObj->Get(opt)->Uint32Value()
      : def;
}

#if (NODE_MODULE_VERSION > 0x000B)
// Node 0.11+ (0.11.3 and below won't compile with these)

# define _NAN_METHOD_ARGS_TYPE const v8::FunctionCallbackInfo<v8::Value>&
# define _NAN_METHOD_ARGS _NAN_METHOD_ARGS_TYPE args
# define _NAN_METHOD_RETURN_TYPE void

# define _NAN_GETTER_ARGS_TYPE const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_GETTER_ARGS _NAN_GETTER_ARGS_TYPE args
# define _NAN_GETTER_RETURN_TYPE void

# define _NAN_SETTER_ARGS_TYPE const v8::PropertyCallbackInfo<void>&
# define _NAN_SETTER_ARGS _NAN_SETTER_ARGS_TYPE args
# define _NAN_SETTER_RETURN_TYPE void

# define _NAN_PROPERTY_GETTER_ARGS_TYPE                                        \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_PROPERTY_GETTER_ARGS _NAN_PROPERTY_GETTER_ARGS_TYPE args
# define _NAN_PROPERTY_GETTER_RETURN_TYPE void

# define _NAN_PROPERTY_SETTER_ARGS_TYPE                                        \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_PROPERTY_SETTER_ARGS _NAN_PROPERTY_SETTER_ARGS_TYPE args
# define _NAN_PROPERTY_SETTER_RETURN_TYPE void

# define _NAN_PROPERTY_ENUMERATOR_ARGS_TYPE                                    \
    const v8::PropertyCallbackInfo<v8::Array>&
# define _NAN_PROPERTY_ENUMERATOR_ARGS _NAN_PROPERTY_ENUMERATOR_ARGS_TYPE args
# define _NAN_PROPERTY_ENUMERATOR_RETURN_TYPE void

# define _NAN_PROPERTY_DELETER_ARGS_TYPE                                       \
    const v8::PropertyCallbackInfo<v8::Boolean>&
# define _NAN_PROPERTY_DELETER_ARGS                                            \
    _NAN_PROPERTY_DELETER_ARGS_TYPE args
# define _NAN_PROPERTY_DELETER_RETURN_TYPE void

# define _NAN_PROPERTY_QUERY_ARGS_TYPE                                         \
    const v8::PropertyCallbackInfo<v8::Integer>&
# define _NAN_PROPERTY_QUERY_ARGS _NAN_PROPERTY_QUERY_ARGS_TYPE args
# define _NAN_PROPERTY_QUERY_RETURN_TYPE void

# define _NAN_INDEX_GETTER_ARGS_TYPE                                           \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_INDEX_GETTER_ARGS _NAN_INDEX_GETTER_ARGS_TYPE args
# define _NAN_INDEX_GETTER_RETURN_TYPE void

# define _NAN_INDEX_SETTER_ARGS_TYPE                                           \
    const v8::PropertyCallbackInfo<v8::Value>&
# define _NAN_INDEX_SETTER_ARGS _NAN_INDEX_SETTER_ARGS_TYPE args
# define _NAN_INDEX_SETTER_RETURN_TYPE void

# define _NAN_INDEX_ENUMERATOR_ARGS_TYPE                                       \
    const v8::PropertyCallbackInfo<v8::Array>&
# define _NAN_INDEX_ENUMERATOR_ARGS _NAN_INDEX_ENUMERATOR_ARGS_TYPE args
# define _NAN_INDEX_ENUMERATOR_RETURN_TYPE void

# define _NAN_INDEX_DELETER_ARGS_TYPE                                          \
    const v8::PropertyCallbackInfo<v8::Boolean>&
# define _NAN_INDEX_DELETER_ARGS _NAN_INDEX_DELETER_ARGS_TYPE args
# define _NAN_INDEX_DELETER_RETURN_TYPE void

# define _NAN_INDEX_QUERY_ARGS_TYPE                                            \
    const v8::PropertyCallbackInfo<v8::Integer>&
# define _NAN_INDEX_QUERY_ARGS _NAN_INDEX_QUERY_ARGS_TYPE args
# define _NAN_INDEX_QUERY_RETURN_TYPE void

  typedef v8::FunctionCallback NanFunctionCallback;

  template<typename T>
  NAN_INLINE v8::Local<T> NanNew() {
    return T::New(v8::Isolate::GetCurrent());
  }

  template<typename T, typename P>
  NAN_INLINE v8::Local<T> NanNew(P arg1) {
    return T::New(v8::Isolate::GetCurrent(), arg1);
  }

  template<typename T>
  NAN_INLINE v8::Local<v8::Signature> NanNew(
      v8::Handle<v8::FunctionTemplate> receiver
    , int argc
    , v8::Handle<v8::FunctionTemplate> argv[] = 0) {
    return v8::Signature::New(v8::Isolate::GetCurrent(), receiver, argc, argv);
  }

  template<typename T>
  NAN_INLINE v8::Local<v8::FunctionTemplate> NanNew(
      NanFunctionCallback callback
    , v8::Handle<v8::Value> data = v8::Handle<v8::Value>()
    , v8::Handle<v8::Signature> signature = v8::Handle<v8::Signature>()) {
    return T::New(v8::Isolate::GetCurrent(), callback, data, signature);
  }

  template<typename T>
  NAN_INLINE v8::Local<T> NanNew(v8::Handle<T> arg1) {
    return v8::Local<T>::New(v8::Isolate::GetCurrent(), arg1);
  }

  template<typename T>
  NAN_INLINE v8::Local<T> NanNew(const v8::Persistent<T> &arg1) {
    return v8::Local<T>::New(v8::Isolate::GetCurrent(), arg1);
  }

  template<typename T, typename P>
  NAN_INLINE v8::Local<T> NanNew(P arg1, int arg2) {
    return T::New(v8::Isolate::GetCurrent(), arg1, arg2);
  }

  template<>
  NAN_INLINE v8::Local<v8::Array> NanNew<v8::Array>() {
    return v8::Array::New(v8::Isolate::GetCurrent());
  }

  template<>
  NAN_INLINE v8::Local<v8::Array> NanNew<v8::Array>(int length) {
    return v8::Array::New(v8::Isolate::GetCurrent(), length);
  }

  template<>
  NAN_INLINE v8::Local<v8::Date> NanNew<v8::Date>(double time) {
    return v8::Date::New(v8::Isolate::GetCurrent(), time).As<v8::Date>();
  }

  template<>
  NAN_INLINE v8::Local<v8::Date> NanNew<v8::Date>(int time) {
    return v8::Date::New(v8::Isolate::GetCurrent(), time).As<v8::Date>();
  }

  typedef v8::UnboundScript NanUnboundScript;
  typedef v8::Script NanBoundScript;

  template<typename T, typename P>
  NAN_INLINE v8::Local<T> NanNew(
      P s
    , const v8::ScriptOrigin& origin
  ) {
    v8::ScriptCompiler::Source source(s, origin);
    return v8::ScriptCompiler::CompileUnbound(
        v8::Isolate::GetCurrent(), &source);
  }

  template<>
  NAN_INLINE v8::Local<NanUnboundScript> NanNew<NanUnboundScript>(
      v8::Local<v8::String> s
  ) {
    v8::ScriptCompiler::Source source(s);
    return v8::ScriptCompiler::CompileUnbound(
        v8::Isolate::GetCurrent(), &source);
  }

  template<>
  NAN_INLINE v8::Local<v8::BooleanObject> NanNew(bool value) {
    return v8::BooleanObject::New(value).As<v8::BooleanObject>();
  }

  template<>
  NAN_INLINE v8::Local<v8::StringObject>
  NanNew<v8::StringObject, v8::Local<v8::String> >(
      v8::Local<v8::String> value) {
    return v8::StringObject::New(value).As<v8::StringObject>();
  }

  template<>
  NAN_INLINE v8::Local<v8::StringObject>
  NanNew<v8::StringObject, v8::Handle<v8::String> >(
      v8::Handle<v8::String> value) {
    return v8::StringObject::New(value).As<v8::StringObject>();
  }

  template<>
  NAN_INLINE v8::Local<v8::NumberObject> NanNew<v8::NumberObject>(double val) {
    return v8::NumberObject::New(
        v8::Isolate::GetCurrent(), val).As<v8::NumberObject>();
  }

  template<typename T>
  NAN_INLINE v8::Local<v8::RegExp> NanNew(
      v8::Handle<v8::String> pattern, v8::RegExp::Flags flags) {
    return v8::RegExp::New(pattern, flags);
  }

  template<typename T>
  NAN_INLINE v8::Local<v8::RegExp> NanNew(
      v8::Local<v8::String> pattern, v8::RegExp::Flags flags) {
    return v8::RegExp::New(pattern, flags);
  }

  template<typename T, typename P>
  NAN_INLINE v8::Local<v8::RegExp> NanNew(
      v8::Handle<v8::String> pattern, v8::RegExp::Flags flags) {
    return v8::RegExp::New(pattern, flags);
  }

  template<typename T, typename P>
  NAN_INLINE v8::Local<v8::RegExp> NanNew(
      v8::Local<v8::String> pattern, v8::RegExp::Flags flags) {
    return v8::RegExp::New(pattern, flags);
  }

  template<>
  NAN_INLINE v8::Local<v8::Uint32> NanNew<v8::Uint32, int32_t>(int32_t val) {
    return v8::Uint32::NewFromUnsigned(
        v8::Isolate::GetCurrent(), val)->ToUint32();
  }

  template<>
  NAN_INLINE v8::Local<v8::Uint32> NanNew<v8::Uint32, uint32_t>(uint32_t val) {
    return v8::Uint32::NewFromUnsigned(
        v8::Isolate::GetCurrent(), val)->ToUint32();
  }

  template<>
  NAN_INLINE v8::Local<v8::Int32> NanNew<v8::Int32, int32_t>(int32_t val) {
    return v8::Int32::New(v8::Isolate::GetCurrent(), val)->ToInt32();
  }

  template<>
  NAN_INLINE v8::Local<v8::Int32> NanNew<v8::Int32, uint32_t>(uint32_t val) {
    return v8::Int32::New(v8::Isolate::GetCurrent(), val)->ToInt32();
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, char *>(
      char *arg
    , int length) {
    return v8::String::NewFromUtf8(
        v8::Isolate::GetCurrent()
      , arg
      , v8::String::kNormalString
      , length);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, const char *>(
      const char *arg
    , int length) {
    return v8::String::NewFromUtf8(
        v8::Isolate::GetCurrent()
      , arg
      , v8::String::kNormalString
      , length);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, char *>(char *arg) {
    return v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), arg);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, const char *>(
      const char *arg) {
    return v8::String::NewFromUtf8(v8::Isolate::GetCurrent(), arg);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, uint8_t *>(
      uint8_t *arg
    , int length) {
    return v8::String::NewFromOneByte(
        v8::Isolate::GetCurrent()
      , arg
      , v8::String::kNormalString
      , length);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, const uint8_t *>(
      const uint8_t *arg
    , int length) {
    return v8::String::NewFromOneByte(
        v8::Isolate::GetCurrent()
      , arg
      , v8::String::kNormalString
      , length);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, uint8_t *>(uint8_t *arg) {
    return v8::String::NewFromOneByte(v8::Isolate::GetCurrent(), arg);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, const uint8_t *>(
      const uint8_t *arg) {
    return v8::String::NewFromOneByte(v8::Isolate::GetCurrent(), arg);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, uint16_t *>(
      uint16_t *arg
    , int length) {
    return v8::String::NewFromTwoByte(
        v8::Isolate::GetCurrent()
      , arg
      , v8::String::kNormalString
      , length);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, const uint16_t *>(
      const uint16_t *arg
    , int length) {
    return v8::String::NewFromTwoByte(
        v8::Isolate::GetCurrent()
      , arg
      , v8::String::kNormalString
      , length);
  }
  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, uint16_t *>(
      uint16_t *arg) {
    return v8::String::NewFromTwoByte(v8::Isolate::GetCurrent(), arg);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String, const uint16_t *>(
      const uint16_t *arg) {
    return v8::String::NewFromTwoByte(v8::Isolate::GetCurrent(), arg);
  }

  template<>
  NAN_INLINE v8::Local<v8::String> NanNew<v8::String>() {
    return v8::String::Empty(v8::Isolate::GetCurrent());
  }

  NAN_INLINE v8::Local<v8::String> NanNew(const char* arg, int length = -1) {
    return NanNew<v8::String>(arg, length);
  }

  NAN_INLINE v8::Local<v8::String> NanNew(
      const uint8_t* arg
    , int length = -1) {
    return NanNew<v8::String>(arg, length);
  }

  NAN_INLINE v8::Local<v8::String> NanNew(
      const uint16_t* arg
    , int length = -1) {
    return NanNew<v8::String>(arg, length);
  }

  NAN_INLINE v8::Local<v8::Number> NanNew(double val) {
    return NanNew<v8::Number>(val);
  }

  NAN_INLINE v8::Local<v8::Integer> NanNew(int val) {
    return NanNew<v8::Integer>(val);
  }

  NAN_INLINE v8::Local<v8::Uint32> NanNew(unsigned int val) {
    return NanNew<v8::Uint32>(val);
  }

  NAN_INLINE v8::Local<v8::Boolean> NanNew(bool val) {
    return NanNew<v8::Boolean>(val);
  }

  NAN_INLINE v8::Local<v8::String> NanNew(
      v8::String::ExternalStringResource *resource) {
    return v8::String::NewExternal(v8::Isolate::GetCurrent(), resource);
  }

  NAN_INLINE v8::Local<v8::String> NanNew(
      v8::String::ExternalAsciiStringResource *resource) {
    return v8::String::NewExternal(v8::Isolate::GetCurrent(), resource);
  }

# define NanScope() v8::HandleScope scope(v8::Isolate::GetCurrent())
# define NanEscapableScope()                                                   \
  v8::EscapableHandleScope scope(v8::Isolate::GetCurrent())

  template<typename T>
  NAN_INLINE v8::Local<T> _NanEscapeScopeHelper(v8::Handle<T> val) {
    return NanNew(val);
  }

  template<typename T>
  NAN_INLINE v8::Local<T> _NanEscapeScopeHelper(v8::Local<T> val) {
    return val;
  }

# define NanEscapeScope(val) scope.Escape(_NanEscapeScopeHelper(val))
# define NanLocker() v8::Locker locker(v8::Isolate::GetCurrent())
# define NanUnlocker() v8::Unlocker unlocker(v8::Isolate::GetCurrent())
# define NanReturnValue(value) return args.GetReturnValue().Set(value)
# define NanReturnUndefined() return
# define NanReturnNull() return args.GetReturnValue().SetNull()
# define NanReturnEmptyString() return args.GetReturnValue().SetEmptyString()

# define NanObjectWrapHandle(obj) obj->handle()

  NAN_INLINE v8::Local<v8::Primitive> NanUndefined() {
    NanEscapableScope();
    return NanEscapeScope(NanNew(v8::Undefined(v8::Isolate::GetCurrent())));
  }

  NAN_INLINE v8::Local<v8::Primitive> NanNull() {
    NanEscapableScope();
    return NanEscapeScope(NanNew(v8::Null(v8::Isolate::GetCurrent())));
  }

  NAN_INLINE v8::Local<v8::Boolean> NanTrue() {
    NanEscapableScope();
    return NanEscapeScope(NanNew(v8::True(v8::Isolate::GetCurrent())));
  }

  NAN_INLINE v8::Local<v8::Boolean> NanFalse() {
    NanEscapableScope();
    return NanEscapeScope(NanNew(v8::False(v8::Isolate::GetCurrent())));
  }

  NAN_INLINE int NanAdjustExternalMemory(int bc) {
    return v8::Isolate::GetCurrent()->AdjustAmountOfExternalAllocatedMemory(bc);
  }

  NAN_INLINE void NanSetTemplate(
      v8::Handle<v8::Template> templ
    , const char *name
    , v8::Handle<v8::Data> value) {
    templ->Set(v8::Isolate::GetCurrent(), name, value);
  }
  

  NAN_INLINE v8::Local<v8::Context> NanGetCurrentContext() {
    return v8::Isolate::GetCurrent()->GetCurrentContext();
  }

  NAN_INLINE void* NanGetInternalFieldPointer(
      v8::Handle<v8::Object> object
    , int index) {
    return object->GetAlignedPointerFromInternalField(index);
  }

  NAN_INLINE void NanSetInternalFieldPointer(
      v8::Handle<v8::Object> object
    , int index
    , void* value) {
    object->SetAlignedPointerInInternalField(index, value);
  }

  NAN_INLINE void NanAddGCEpilogueCallback(
      v8::Isolate::GCEpilogueCallback callback
    , v8::GCType gc_type_filter = v8::kGCTypeAll) {
    v8::Isolate::GetCurrent()->AddGCEpilogueCallback(callback, gc_type_filter);
  }

  NAN_INLINE void NanRemoveGCEpilogueCallback(
      v8::Isolate::GCEpilogueCallback callback) {
    v8::Isolate::GetCurrent()->RemoveGCEpilogueCallback(callback);
  }

  NAN_INLINE void NanAddGCPrologueCallback(
      v8::Isolate::GCPrologueCallback callback
    , v8::GCType gc_type_filter = v8::kGCTypeAll) {
    v8::Isolate::GetCurrent()->AddGCPrologueCallback(callback, gc_type_filter);
  }

  NAN_INLINE void NanRemoveGCPrologueCallback(
      v8::Isolate::GCPrologueCallback callback) {
    v8::Isolate::GetCurrent()->RemoveGCPrologueCallback(callback);
  }

  NAN_INLINE void NanGetHeapStatistics(
      v8::HeapStatistics *heap_statistics) {
    v8::Isolate::GetCurrent()->GetHeapStatistics(heap_statistics);
  }

  NAN_DEPRECATED NAN_INLINE v8::Local<v8::String> NanSymbol(
      const char* data, int length = -1) {
    return NanNew<v8::String>(data, length);
  }

  template<typename T>
  NAN_INLINE void NanAssignPersistent(
      v8::Persistent<T>& handle
    , v8::Handle<T> obj) {
      handle.Reset(v8::Isolate::GetCurrent(), obj);
  }

  template<typename T>
  NAN_INLINE void NanAssignPersistent(
      v8::Persistent<T>& handle
    , const v8::Persistent<T>& obj) {
      handle.Reset(v8::Isolate::GetCurrent(), obj);
  }

  template<typename T, typename P>
  class _NanWeakCallbackData;

  template<typename T, typename P>
  struct _NanWeakCallbackInfo {
    typedef void (*Callback)(const _NanWeakCallbackData<T, P>& data);
    NAN_INLINE _NanWeakCallbackInfo(v8::Handle<T> handle, P* param, Callback cb)
      : parameter(param), callback(cb) {
       NanAssignPersistent(persistent, handle);
    }

    NAN_INLINE ~_NanWeakCallbackInfo() {
      persistent.Reset();
    }

    P* const parameter;
    Callback const callback;
    v8::Persistent<T> persistent;
  };

  template<typename T, typename P>
  class _NanWeakCallbackData {
   public:
    NAN_INLINE _NanWeakCallbackData(_NanWeakCallbackInfo<T, P> *info)
      : info_(info) { }

    NAN_INLINE v8::Local<T> GetValue() const {
      return NanNew(info_->persistent);
    }

    NAN_INLINE P* GetParameter() const { return info_->parameter; }

    NAN_INLINE bool IsNearDeath() const {
      return info_->persistent.IsNearDeath();
    }

    NAN_INLINE void Revive() const;

    NAN_INLINE _NanWeakCallbackInfo<T, P>* GetCallbackInfo() const {
      return info_;
    }

    NAN_DEPRECATED NAN_INLINE void Dispose() const {
    }

   private:
    _NanWeakCallbackInfo<T, P>* info_;
  };

  template<typename T, typename P>
  static void _NanWeakCallbackDispatcher(
    const v8::WeakCallbackData<T, _NanWeakCallbackInfo<T, P> > &data) {
      _NanWeakCallbackInfo<T, P> *info = data.GetParameter();
      _NanWeakCallbackData<T, P> wcbd(info);
      info->callback(wcbd);
      if (wcbd.IsNearDeath()) {
        delete wcbd.GetCallbackInfo();
      }
  }

  template<typename T, typename P>
  NAN_INLINE void _NanWeakCallbackData<T, P>::Revive() const {
      info_->persistent.SetWeak(info_, &_NanWeakCallbackDispatcher<T, P>);
  }

template<typename T, typename P>
NAN_INLINE _NanWeakCallbackInfo<T, P>* NanMakeWeakPersistent(
    v8::Handle<T> handle
  , P* parameter
  , typename _NanWeakCallbackInfo<T, P>::Callback callback) {
    _NanWeakCallbackInfo<T, P> *cbinfo =
     new _NanWeakCallbackInfo<T, P>(handle, parameter, callback);
    cbinfo->persistent.SetWeak(cbinfo, &_NanWeakCallbackDispatcher<T, P>);
    return cbinfo;
}

# define NAN_WEAK_CALLBACK(name)                                               \
    template<typename T, typename P>                                           \
    static void name(const _NanWeakCallbackData<T, P> &data)

# define _NAN_ERROR(fun, errmsg) fun(NanNew<v8::String>(errmsg))

# define _NAN_THROW_ERROR(fun, errmsg)                                         \
    do {                                                                       \
      NanScope();                                                              \
      v8::Isolate::GetCurrent()->ThrowException(_NAN_ERROR(fun, errmsg));      \
    } while (0);

  NAN_INLINE v8::Local<v8::Value> NanError(const char* errmsg) {
    return  _NAN_ERROR(v8::Exception::Error, errmsg);
  }

  NAN_INLINE void NanThrowError(const char* errmsg) {
    _NAN_THROW_ERROR(v8::Exception::Error, errmsg);
  }

  NAN_INLINE void NanThrowError(v8::Handle<v8::Value> error) {
    NanScope();
    v8::Isolate::GetCurrent()->ThrowException(error);
  }

  NAN_INLINE v8::Local<v8::Value> NanError(
      const char *msg
    , const int errorNumber
  ) {
    v8::Local<v8::Value> err = v8::Exception::Error(NanNew<v8::String>(msg));
    v8::Local<v8::Object> obj = err.As<v8::Object>();
    obj->Set(NanNew<v8::String>("code"), NanNew<v8::Integer>(errorNumber));
    return err;
  }

  NAN_INLINE void NanThrowError(
      const char *msg
    , const int errorNumber
  ) {
    NanThrowError(NanError(msg, errorNumber));
  }

  NAN_INLINE v8::Local<v8::Value> NanTypeError(const char* errmsg) {
    return _NAN_ERROR(v8::Exception::TypeError, errmsg);
  }

  NAN_INLINE void NanThrowTypeError(const char* errmsg) {
    _NAN_THROW_ERROR(v8::Exception::TypeError, errmsg);
  }

  NAN_INLINE v8::Local<v8::Value> NanRangeError(const char* errmsg) {
    return _NAN_ERROR(v8::Exception::RangeError, errmsg);
  }

  NAN_INLINE void NanThrowRangeError(const char* errmsg) {
    _NAN_THROW_ERROR(v8::Exception::RangeError, errmsg);
  }

  template<typename T> NAN_INLINE void NanDisposePersistent(
      v8::Persistent<T> &handle
  ) {
    handle.Reset();
  }

  NAN_INLINE v8::Local<v8::Object> NanNewBufferHandle (
      char *data
    , size_t length
    , node::smalloc::FreeCallback callback
    , void *hint
  ) {
    return node::Buffer::New(
        v8::Isolate::GetCurrent(), data, length, callback, hint);
  }

  NAN_INLINE v8::Local<v8::Object> NanNewBufferHandle (
      const char *data
    , uint32_t size
  ) {
    return node::Buffer::New(v8::Isolate::GetCurrent(), data, size);
  }

  NAN_INLINE v8::Local<v8::Object> NanNewBufferHandle (uint32_t size) {
    return node::Buffer::New(v8::Isolate::GetCurrent(), size);
  }

  NAN_INLINE v8::Local<v8::Object> NanBufferUse(
      char* data
    , uint32_t size
  ) {
    return node::Buffer::Use(v8::Isolate::GetCurrent(), data, size);
  }

  NAN_INLINE bool NanHasInstance(
      v8::Persistent<v8::FunctionTemplate>& function_template
    , v8::Handle<v8::Value> value
  ) {
    return NanNew(function_template)->HasInstance(value);
  }

  NAN_INLINE v8::Local<v8::Context> NanNewContextHandle(
      v8::ExtensionConfiguration* extensions = NULL
    , v8::Handle<v8::ObjectTemplate> tmpl = v8::Handle<v8::ObjectTemplate>()
    , v8::Handle<v8::Value> obj = v8::Handle<v8::Value>()
  ) {
    v8::Isolate* isolate = v8::Isolate::GetCurrent();
    return v8::Local<v8::Context>::New(
        isolate
      , v8::Context::New(isolate, extensions, tmpl, obj)
    );
  }

  NAN_INLINE v8::Local<NanBoundScript> NanCompileScript(
      v8::Local<v8::String> s
    , const v8::ScriptOrigin& origin
  ) {
    v8::ScriptCompiler::Source source(s, origin);
    return v8::ScriptCompiler::Compile(v8::Isolate::GetCurrent(), &source);
  }

  NAN_INLINE v8::Local<NanBoundScript> NanCompileScript(
      v8::Local<v8::String> s
  ) {
    v8::ScriptCompiler::Source source(s);
    return v8::ScriptCompiler::Compile(v8::Isolate::GetCurrent(), &source);
  }

  NAN_INLINE v8::Local<v8::Value> NanRunScript(
      v8::Handle<NanUnboundScript> script
  ) {
    return script->BindToCurrentContext()->Run();
  }

  NAN_INLINE v8::Local<v8::Value> NanRunScript(
      v8::Handle<NanBoundScript> script
  ) {
    return script->Run();
  }

  NAN_INLINE v8::Local<v8::Value> NanMakeCallback(
      v8::Handle<v8::Object> target
    , v8::Handle<v8::Function> func
    , int argc
    , v8::Handle<v8::Value>* argv) {
    return NanNew(node::MakeCallback(
        v8::Isolate::GetCurrent(), target, func, argc, argv));
  }

#else
// Node 0.8 and 0.10

# define _NAN_METHOD_ARGS_TYPE const v8::Arguments&
# define _NAN_METHOD_ARGS _NAN_METHOD_ARGS_TYPE args
# define _NAN_METHOD_RETURN_TYPE v8::Handle<v8::Value>

# define _NAN_GETTER_ARGS_TYPE const v8::AccessorInfo &
# define _NAN_GETTER_ARGS _NAN_GETTER_ARGS_TYPE args
# define _NAN_GETTER_RETURN_TYPE v8::Handle<v8::Value>

# define _NAN_SETTER_ARGS_TYPE const v8::AccessorInfo &
# define _NAN_SETTER_ARGS _NAN_SETTER_ARGS_TYPE args
# define _NAN_SETTER_RETURN_TYPE void

# define _NAN_PROPERTY_GETTER_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_PROPERTY_GETTER_ARGS _NAN_PROPERTY_GETTER_ARGS_TYPE args
# define _NAN_PROPERTY_GETTER_RETURN_TYPE v8::Handle<v8::Value>

# define _NAN_PROPERTY_SETTER_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_PROPERTY_SETTER_ARGS _NAN_PROPERTY_SETTER_ARGS_TYPE args
# define _NAN_PROPERTY_SETTER_RETURN_TYPE v8::Handle<v8::Value>

# define _NAN_PROPERTY_ENUMERATOR_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_PROPERTY_ENUMERATOR_ARGS _NAN_PROPERTY_ENUMERATOR_ARGS_TYPE args
# define _NAN_PROPERTY_ENUMERATOR_RETURN_TYPE v8::Handle<v8::Array>

# define _NAN_PROPERTY_DELETER_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_PROPERTY_DELETER_ARGS _NAN_PROPERTY_DELETER_ARGS_TYPE args
# define _NAN_PROPERTY_DELETER_RETURN_TYPE v8::Handle<v8::Boolean>

# define _NAN_PROPERTY_QUERY_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_PROPERTY_QUERY_ARGS _NAN_PROPERTY_QUERY_ARGS_TYPE args
# define _NAN_PROPERTY_QUERY_RETURN_TYPE v8::Handle<v8::Integer>

# define _NAN_INDEX_GETTER_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_INDEX_GETTER_ARGS _NAN_INDEX_GETTER_ARGS_TYPE args
# define _NAN_INDEX_GETTER_RETURN_TYPE v8::Handle<v8::Value>

# define _NAN_INDEX_SETTER_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_INDEX_SETTER_ARGS _NAN_INDEX_SETTER_ARGS_TYPE args
# define _NAN_INDEX_SETTER_RETURN_TYPE v8::Handle<v8::Value>

# define _NAN_INDEX_ENUMERATOR_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_INDEX_ENUMERATOR_ARGS _NAN_INDEX_ENUMERATOR_ARGS_TYPE args
# define _NAN_INDEX_ENUMERATOR_RETURN_TYPE v8::Handle<v8::Array>

# define _NAN_INDEX_DELETER_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_INDEX_DELETER_ARGS _NAN_INDEX_DELETER_ARGS_TYPE args
# define _NAN_INDEX_DELETER_RETURN_TYPE v8::Handle<v8::Boolean>

# define _NAN_INDEX_QUERY_ARGS_TYPE const v8::AccessorInfo&
# define _NAN_INDEX_QUERY_ARGS _NAN_INDEX_QUERY_ARGS_TYPE args
# define _NAN_INDEX_QUERY_RETURN_TYPE v8::Handle<v8::Integer>

  typedef v8::InvocationCallback NanFunctionCallback;

  NAN_DEPRECATED NAN_INLINE v8::Local<v8::String> NanSymbol(
      const char* data, int length = -1) {
    return v8::String::NewSymbol(data, length);
  }

  template<typename T>
  NAN_INLINE v8::Local<T> NanNew() {
    return v8::Local<T>::New(T::New());
  }

  template<typename T>
  NAN_INLINE v8::Local<T> NanNew(v8::Handle<T> arg) {
    return v8::Local<T>::New(arg);
  }

  template<typename T>
  NAN_INLINE v8::Local<v8::Signature> NanNew(
      v8::Handle<v8::FunctionTemplate> receiver
    , int argc
    , v8::Handle<v8::FunctionTemplate> argv[] = 0) {
    return v8::Signature::New(receiver, argc, argv);
  }

  template<typename T>
  NAN_INLINE v8::Local<v8::FunctionTemplate> NanNew(
      NanFunctionCallback callback
    , v8::Handle<v8::Value> data = v8::Handle<v8::Value>()
    , v8::Handle<v8::Signature> signature = v8::Handle<v8::Signature>()) {
    return T::New(callback, data, signature);
  }

  template<typename T>
  NAN_INLINE v8::Local<T> NanNew(const v8::Persistent<T> &arg) {
    return v8::Local<T>::New(arg);
  }

  template<typename T, typename P>
  NAN_INLINE v8::Local<T> NanNew(P arg) {
    return v8::Local<T>::New(T::New(arg));
  }

  template<typename T, typename P>
  NAN_INLINE v8::Local<T> NanNew(P arg, int length) {
    return v8::Local<T>::New(T::New(arg, length));
  }

  template<typename T>
  NAN_INLINE v8::Local<v8::RegExp> NanNew(
      v8::Handle<v8::String> pattern, v8::RegExp::Flags flags) {
    return v8::RegExp::New(pattern, flags);
  }

  template<typename T>
  NAN_INLINE v8::Local<v8::RegExp> NanNew(
      v8::Local<v8::String> pattern, v8::RegExp::Flags flags) {
    return v8::RegExp::New(pattern, flags);
  }

  template<typename T, typename P>
  NAN_INLINE v8::Local<v8::RegExp> NanNew(
      v8::Handle<v8::String> pattern, v8::RegExp::Flags flags) {
    return v8::RegExp::New(pattern, f